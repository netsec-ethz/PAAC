package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"time"

	"github.com/casbin/casbin/v2"
	"github.com/scionproto/scion/pkg/addr"
	"github.com/scionproto/scion/pkg/daemon"
	"github.com/scionproto/scion/pkg/snet"

	. "paac/paac"
)

// TODO: check CAIDA license conditions
func main() {
	Main()
}

func Main() {
	// For this to work, scionproto needs to be running with a local topology.
	// See https://docs.scion.org/en/latest/dev/run.html#running-scion-locally
	// The addresses in this function are those from topo/single_path_test.topo
	serverIA, err := addr.ParseIA("1-ff00:0:100") // topo/single_path_test.topo
	if err != nil {
		log.Fatalln(err)
	}
	serverAddr, err := net.ResolveUDPAddr("udp", "127.0.0.1:6969")
	if err != nil {
		log.Fatalln(err)
	}
	serverDaemonAddress := "127.0.0.52:30255" // topo/single_path_test.topo

	clientIA, err := addr.ParseIA("3-ff00:0:300") // topo/single_path_test.topo
	if err != nil {
		log.Fatalln(err)
	}
	clientAddr, err := net.ResolveUDPAddr("udp", "127.0.0.1:6969")
	if err != nil {
		log.Fatalln(err)
	}
	clientDaemonAddress := "127.0.0.148:30255" // topo/single_path_test.topo

	// Set logging level for the package. Default is 0
	LogLevel = 1
	// Create logger, we will use the same one for all endpoints/services
	// NOTE: This logger will *not* be used for fatal errors. Those will still
	// go to the default logger from the log package
	logger := log.New(os.Stdout, fmt.Sprintf("INFO-lvl%v: ", LogLevel), log.Ltime|log.Lmicroseconds|log.Lshortfile)

	// Create SCION endpoints from which we can send/receive SCION packets
	serverEndpoint := NewScionEndpoint(context.Background(), logger, serverDaemonAddress, serverIA, serverAddr)
	clientEndpoint := NewScionEndpoint(context.Background(), logger, clientDaemonAddress, clientIA, clientAddr)

	// Initialize a basic casbin SyncedEnforcer. For more information about casbin model configuration
	// and policy definition, see https://casbin.org/docs/abac.
	enforcer, err := casbin.NewSyncedEnforcer("examples/paac_model.conf", "examples/main_policy.csv")
	if err != nil {
		log.Fatalln(err)
	}

	// Initialize attribute handlers to maintain various sets of attributes
	// The network attribute handler is responsible for extracting path attributes
	netAttHandler := NewNetworkAttributeHandler(context.Background(), logger, serverDaemonAddress)
	netAttHandler.ExternalAttributeHandler = NewGenericAttributeHandler(logger, map[string]any{"TrustLevel": 1, "Latency": 60})
	// Manually add some network attributes that aren't directly extracted from the path,
	// Which may be generated by e.g. an external monitoring system
	paths, err := serverEndpoint.DaemonConnector.Paths(context.Background(), clientIA, serverIA, daemon.PathReqFlags{})
	checkError(err, "Failed to retrieve network path for manual network attributes")
	checkOk(len(paths) >= 1, "Daemon returned no paths for manual networka attributes")
	checkError(netAttHandler.ExternalAttributeHandler.Put(
		string(snet.Fingerprint(paths[0])),
		map[string]any{"TrustLevel": 4, "Latency": 10},
	),
		"Error manually storing network attributes",
	)
	// Set cache preferences
	netAttHandler.UseCache(true)
	netAttHandler.SetCacheExpiry(1 * time.Hour)

	// This handler will store information for our request subjects
	subAttHandler := NewGenericAttributeHandler(logger, map[string]any{"id": "", "clearance": false, "age": 0})
	// Add some attributes
	checkError(subAttHandler.Put("Alice", map[string]any{"id": "Alice", "age": 23}), "Error storing attribute")
	checkError(subAttHandler.Put("Bob", map[string]any{"id": "Bob", "clearance": true, "age": 21}), "Error storing attribute")

	// This handler will store information for our request objects
	objAttHandler := NewGenericAttributeHandler(logger, map[string]any{"id": "", "size": 0, "restricted": false, "TrustLevel": 1, "owner": ""})
	// Add some attributes
	checkError(objAttHandler.Put("data1", map[string]any{"id": "data1", "size": 500, "restricted": false, "owner": "Alice", "TrustLevel": 2}), "Error storing attribute")
	checkError(objAttHandler.Put("data2", map[string]any{"id": "data2", "size": 200, "restricted": true, "owner": "Bob", "TrustLevel": 0}), "Error storing attribute")
	checkError(objAttHandler.Put("data3", map[string]any{"id": "data3", "size": 700, "restricted": true, "owner": "Bob", "TrustLevel": 5}), "Error storing attribute")

	paacEndpoint := NewPAACEndPoint(logger, enforcer, serverEndpoint, netAttHandler, subAttHandler, objAttHandler)
	defer paacEndpoint.Close()

	// Start the endpoint with desired parallelism.
	// The ratio of numEnforcers:numRequestBuilders depends on the application bottleneck.
	// The longer the Enforce() call for an individual casbin enforcer,
	// the fewer builders are required to keep the enforcer(s) supplied with
	// requests.
	// The longer it takes to collect attributes and build the request, the more
	// builders are required.

	// here set to 1 to provide a cleaner console output
	paacEndpoint.Start(1, 1)

	// example setting to number of cores instead:
	// paacEndpoint.Start(runtime.NumCPU(), runtime.NumCPU())
	paacClient := NewPAACClient(logger, clientEndpoint)
	defer paacClient.Close()

	request := &PAACRequest{
		ClientID:   "Alice",
		ObjectID:   "data1",
		AccessType: "read",
	}
	logger.Printf("Sending request: %+v\n", request)
	reply := paacClient.RequestAccess(context.Background(), serverIA, serverAddr, request)
	logger.Printf("Received reply: %+v,  OK: %t, err: %v\n", reply.Request, reply.Ok, reply.Err)

	request = &PAACRequest{
		ClientID:   "Alice",
		ObjectID:   "data2",
		AccessType: "read",
	}
	logger.Printf("Sending request: %+v\n", request)
	reply = paacClient.RequestAccess(context.Background(), serverIA, serverAddr, request)
	logger.Printf("Received reply: %+v,  OK: %t, err: %v\n", reply.Request, reply.Ok, reply.Err)

	request = &PAACRequest{
		ClientID:   "Bob",
		ObjectID:   "data2",
		AccessType: "write",
	}
	logger.Printf("Sending request: %+v\n", request)
	reply = paacClient.RequestAccess(context.Background(), serverIA, serverAddr, request)
	logger.Printf("Received reply: %+v,  OK: %t, err: %v\n", reply.Request, reply.Ok, reply.Err)

	request = &PAACRequest{
		ClientID:   "Bob",
		ObjectID:   "data3",
		AccessType: "write",
	}
	logger.Printf("Sending request: %+v\n", request)
	reply = paacClient.RequestAccess(context.Background(), serverIA, serverAddr, request)
	logger.Printf("Received reply: %+v,  OK: %t, err: %v\n", reply.Request, reply.Ok, reply.Err)
}

func checkError(err error, msg string) {
	if err != nil {
		if msg == "" {
			msg = "Main error"
		}
		log.Fatalln(msg+": ", err)
	}
}

func checkOk(ok bool, msg string) {
	if !ok {
		if msg == "" {
			msg = "Main returned not ok"
		}
		log.Fatalln(msg)
	}
}
